---
title: "Read Quality Assurance"
editor: visual
author: "Joe Boktor"
date: '2022-11-16'
format: 
  html:
    self-contained: true
    code-fold: true
    code-tools: true
    theme: cosmo
    column: page
    fig-align: right
    fig-height: 8
    fig-width: 14 
---

Here we will explore quality control parameters for whole blood whole genome sequencing BAM files. Rigorous quality control is essential as data downstream from this section will impact many analyses. Questions of interest include:

1.  What is the frequency of singleton reads in the unmapped read population?
2.  Are singleton reads exclusively reads whose mate mapped to an alternative reference genome (in this case GRCh38), or are singleton reads an independent read population that is expected in paired end sequencing?
3.  Where to reads whose mate maps to the human genome map to in the human genome?
    -   If this is in a specific region, is this due to limitations in the human reference genome and should we trust it?
4.  What quality control filtering approaches should be used?
    -   Read length

    -   Base Quality

    -   Average Quality

    -   Complexity

    -   ...

To begin answering these questions we will download a small subset of CRAM files and convert them to BAM files.

To determine the

Next we will explore the frequencies of paired/single-end read populations, determine their quality and examine the reads mo

```{r}
#| warning: false

library(glue)
library(purrr)
library(tibble)
library(magrittr)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(ggside)
library(ggsci)
library(ggpubr)
```

```{r}
met_df <- readRDS("../data/interim/metadata/2022-11-04_static_metdata.rds")

met_df %<>% select(
  participant_id,
  study,
  diagnosis_at_baseline,
  case_control_other_at_baseline,
  age_at_baseline,
  ethnicity,
  sex,
  race
)

```

```{r}

readstats_dir <- "../data/interim/readqc/"
readqc_stats <- readRDS(glue("{readstats_dir}2022-11-15_bbduk-stats-df.rds") ) %>% 
  rename(participant_id = sample_id)

df_readqc_stats <-
  readqc_stats %>%
  column_to_rownames(var = "participant_id") %>%
  mutate_all(as.numeric) %>%
  mutate(
    percent_reads_removed = 100 * ((input_reads - final_reads)/input_reads) ,
    percent_bases_removed = 100 * ((input_bases - final_bases)/input_bases)
  ) %>% 
  rownames_to_column(var = "participant_id") %>%
  mutate(read_class = sub(".*_", "", participant_id)) %>% 
  mutate(participant_id = str_replace(participant_id, glue("_{read_class}"),""))

df_readqc_stats %>% glimpse()
```

```{r}

df_readqc_stats %>% 
  left_join(met_df, by = "participant_id") %>% 
  ggplot(aes(input_bases, final_bases)) +
  geom_point(aes(color = study), shape = 21, alpha = 0.5, size = 0.4) +
  scale_x_log10(limits = c(1e7, 1e10)) +
  scale_y_log10(limits = c(1e7, 1e10)) +
  geom_smooth(method = "lm", se = F, aes(color = study)) +
  theme_bw() +
  coord_fixed() +
  scale_color_npg() +
  stat_regline_equation(label.y.npc = 0.95) +
  stat_cor(label.y.npc = 0.9) +
  facet_grid(~read_class)

```

```{r}
#| fig-cap: Total read input by final quality trimmed reads, binned by forward/reverse/singleton read class. 

df_readqc_stats %>% 
  left_join(met_df, by = "participant_id") %>% 
  ggplot(aes(input_reads, final_reads)) +
  geom_point(aes(color = study), shape = 21, alpha = 0.5, size = 0.4) +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "lm", se = F, aes(color = study)) +
  theme_bw() +
  coord_fixed() +
  scale_color_npg() +
  stat_regline_equation(label.y.npc = 0.95) +
  stat_cor(label.y.npc = 0.9) +
  facet_grid(~read_class)

```

```{r}

df_readqc_stats %>% 
  ggplot(aes(final_reads+ 1)) +
  geom_histogram(bins = 300) +
  geom_vline(xintercept = 1e6) +
  scale_x_log10() +
  facet_grid(~read_class)
```

```{r}

df_readqc_stats_paired <- df_readqc_stats %>%
  filter(read_class != "single") %>%
  group_by(participant_id) %>%
  summarize(across(
    !c(read_class, percent_reads_removed, percent_bases_removed),
    sum
  ))  %>% 
  dplyr::rename_if(is.numeric, ~paste0(., "_paired"))

df_readqc_stats_single <- 
  df_readqc_stats %>% 
  filter(read_class == "single") %>% 
  select(-read_class) %>% 
  dplyr::rename_if(is.numeric, ~paste0(., "_single"))

df_readqc_stats_wide <- 
  full_join(df_readqc_stats_paired, df_readqc_stats_single,
             by = c("participant_id"))

```

Observing the ratio of paired vs singlet read counts

```{r}

df_readqc_stats_wide %>% 
  ggplot() +
  geom_histogram(aes(x=final_reads_paired + 1, fill = "paired"), bins = 600, alpha = 0.6) +
  geom_histogram(aes(x=final_reads_single + 1, fill = "single"), bins = 600, alpha = 0.6) +
  scale_x_log10() +
  scale_fill_manual(values = c("paired" = "blue", "single" = "orange")) +
  labs(fill = NULL)

```

Conclusion: Single reads have a more narrow distribution,

How do read quality distributions compare between paired vs singlet reads?

```{r}

df_readqc_stats_long_readclass <- df_readqc_stats_wide %>%
  pivot_longer(
    !participant_id,
    names_to = c("metric", ".value"),
    names_pattern = "(.+)_(.+$)"
  )

df_readqc_stats_long <- df_readqc_stats_long_readclass %>% 
  pivot_longer(c(paired, single), names_to = "read_class", values_to = "value")
read_metrics <- c("input_reads", "final_reads", "input_bases", "final_bases")

df_readqc_stats_long_readclass %>% 
  filter(metric %in% read_metrics) %>% 
  ggplot(aes(x = metric, y = paired / single)) +
  geom_point(position = position_jitter(height = 0, width = 0.2), alpha = 0.2) +
  geom_boxplot(outlier.alpha = 0) +
  scale_y_log10()

df_readqc_stats_long %>% 
  filter(metric %in% read_metrics) %>% 
  mutate(metric = factor(metric, levels = read_metrics)) %>% 
  ggplot(aes(x = metric, y =value)) +
  geom_point(position = position_jitter(height = 0, width = 0.2), alpha = 0.2) +
  geom_boxplot(outlier.alpha = 0) +
  facet_wrap(~read_class) +
  scale_y_log10()
```

```{r}

!"echo $USER"

```
